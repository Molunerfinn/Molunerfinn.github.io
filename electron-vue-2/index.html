<!doctype html><html lang=en><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,maximum-scale=1" name=viewport><meta content=Electron-vue开发实战1——Main进程和Renderer进程的简单开发 name=description><meta content=前端,Electron,Vue,Electron-vue name=keywords><meta content=Molunerfinn name=author><meta content=Molunerfinn name=copyright><meta content=https://pic.molunerfinn.com/blog/avatar.jpeg property=og:image><meta content=https://pic.molunerfinn.com/blog/avatar.jpeg itemprop=image><title>Electron-vue开发实战1——Main进程和Renderer进程的简单开发 | MARKSZのBlog</title><link rel="shortcut icon" href=/favicon.ico><link href=/css/index.css rel=stylesheet><link href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1" rel=stylesheet><meta content="telephone=no" name=format-detection><meta content=on http-equiv=x-dns-prefetch-control><link href=https://cdn.jsdelivr.net rel=dns-prefetch><link href=https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js></script><link href=https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js></script><link href=/manifest.json rel=manifest><link href=/manifest.json rel=manifest><link href=https://hm.baidu.com rel=dns-prefetch><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?19a7ebdbb87f2403773c7ab0cae16d21";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link href=https://www.google-analytics.com rel=dns-prefetch><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-105869658-1', 'auto');
ga('send', 'pageview');</script><meta content=kqRRHxwgvTJaCGlm5oGKbd7XGNwMLir6E0Q-VcQ3fJc name=google-site-verification><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"BGLU1ICJFH","apiKey":"85948beeaf121424b806828adc21c8b5","indexName":"mofinn","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
}</script><meta content="Hexo 8.1.1" name=generator><link href=/atom.xml rel=alternate title=MARKSZのBlog type=application/atom+xml><body><canvas class=fireworks></canvas><i class="fa fa-arrow-right" aria-hidden=true id=toggle-sidebar></i><div data-display=true id=sidebar><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class=sidebar-toc><div class=sidebar-toc__title>Catalog</div><div class=sidebar-toc__progress><span class=progress-notice>You've read</span><span class=progress-num>0</span><span class=progress-percentage>%</span><div class=sidebar-toc__progress-bar></div></div><div class=sidebar-toc__content><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%89%8D%E8%A8%80><span class=toc-number>1.</span> <span class=toc-text>前言</span></a><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%AF%B4%E6%98%8E><span class=toc-number>2.</span> <span class=toc-text>说明</span></a><li class="toc-item toc-level-2"><a class=toc-link href=#Main%E8%BF%9B%E7%A8%8B%E5%92%8CRenderer%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86><span class=toc-number>3.</span> <span class=toc-text>Main进程和Renderer进程的基本认识</span></a><li class="toc-item toc-level-2"><a class=toc-link href=#Main%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91><span class=toc-number>4.</span> <span class=toc-text>Main进程开发</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#app><span class=toc-number>4.1.</span> <span class=toc-text>app</span></a><li class="toc-item toc-level-3"><a class=toc-link href=#BrowserWindow><span class=toc-number>4.2.</span> <span class=toc-text>BrowserWindow</span></a><li class="toc-item toc-level-3"><a class=toc-link href=#Tray><span class=toc-number>4.3.</span> <span class=toc-text>Tray</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6><span class=toc-number>4.3.1.</span> <span class=toc-text>鼠标左键点击事件</span></a><li class="toc-item toc-level-4"><a class=toc-link href=#%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6><span class=toc-number>4.3.2.</span> <span class=toc-text>鼠标右键点击事件</span></a></ol><li class="toc-item toc-level-3"><a class=toc-link href=#Menu><span class=toc-number>4.4.</span> <span class=toc-text>Menu</span></a></ol><li class="toc-item toc-level-2"><a class=toc-link href=#Renderer%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91><span class=toc-number>5.</span> <span class=toc-text>Renderer进程开发</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%AF%B7%E4%BD%BF%E7%94%A8Hash%E6%A8%A1%E5%BC%8F><span class=toc-number>5.1.</span> <span class=toc-text>请使用Hash模式</span></a><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84titlebar><span class=toc-number>5.2.</span> <span class=toc-text>实现自己的titlebar</span></a><li class="toc-item toc-level-3"><a class=toc-link href=#drag-drop%E7%9A%84%E9%81%BF%E5%85%8D><span class=toc-number>5.3.</span> <span class=toc-text>drag&drop的避免</span></a><li class="toc-item toc-level-3"><a class=toc-link href=#remote%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8><span class=toc-number>5.4.</span> <span class=toc-text>remote模块的使用</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#shell><span class=toc-number>5.4.1.</span> <span class=toc-text>shell</span></a><li class="toc-item toc-level-4"><a class=toc-link href=#dialog><span class=toc-number>5.4.2.</span> <span class=toc-text>dialog</span></a><li class="toc-item toc-level-4"><a class=toc-link href=#Menu%E5%92%8CBrowserWindow%E7%9A%84%E5%BA%94%E7%94%A8><span class=toc-number>5.4.3.</span> <span class=toc-text>Menu和BrowserWindow的应用</span></a></ol><li class="toc-item toc-level-3"><a class=toc-link href=#main%E8%BF%9B%E7%A8%8B%E5%92%8Crenderer%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1><span class=toc-number>5.5.</span> <span class=toc-text>main进程和renderer进程的通信</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#ipcMain%E5%92%8CipcRenderer><span class=toc-number>5.5.1.</span> <span class=toc-text>ipcMain和ipcRenderer</span></a><li class="toc-item toc-level-4"><a class=toc-link href=#webContents><span class=toc-number>5.5.2.</span> <span class=toc-text>webContents</span></a></ol></ol><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%80%BB%E7%BB%93><span class=toc-number>6.</span> <span class=toc-text>总结</span></a></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src=https://pic.molunerfinn.com/blog/avatar.jpeg></div><div class="author-info__name text-center">Molunerfinn</div><div class="author-info__description text-center">For MElody</div><div class=follow-button><a href=https://github.com/Molunerfinn>Follow Me</a></div><hr><div class=author-info-articles><a class="author-info-articles__archives article-meta" href=/archives><span class=pull-left>Articles</span><span class=pull-right>78</span></a><a class="author-info-articles__tags article-meta" href=/tags><span class=pull-left>Tags</span><span class=pull-right>24</span></a><a class="author-info-articles__categories article-meta" href=/categories><span class=pull-left>Categories</span><span class=pull-right>24</span></a></div><hr><div class=author-info-links><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href=https://molunerfinn.com>Molunerfinn</a><a class="author-info-links__name text-center" href=https://elody-07.github.io>Elody</a><a class="author-info-links__name text-center" href=https://elmagnifico.tech/>Elmagnifico</a></div></div></div><div id=content-outer><div style="background-image: url(https://pics.molunerfinn.com/blog/blog-bg.jpg)" id=top-container><div id=page-header><span class=pull-left> <a href=/ id=site-name>MARKSZのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden=true></i><span class="pull-right menus"> <a class=site-page href=/about>About</a><a class=site-page href=/archives>Archives</a><a class=site-page href=/tags>Tags</a><a class=site-page href=/categories>Categories</a></span><span class=pull-right><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id=post-info><div id=post-title>Electron-vue开发实战1——Main进程和Renderer进程的简单开发</div><div id=post-meta><time class=post-meta__date><i class="fa fa-calendar" aria-hidden=true></i> 2018-01-17</time><span class=post-meta__separator>|</span><i class="fa fa-inbox post-meta__icon" aria-hidden=true></i><a class=post-meta__categories href=/categories/Web/>Web</a><i class="fa fa-angle-right" aria-hidden=true></i><i class="fa fa-inbox post-meta__icon" aria-hidden=true></i><a class=post-meta__categories href=/categories/Web/%E5%BC%80%E5%8F%91/>开发</a><div class=post-meta-wordcount><span>Word count: </span><span class=word-count>7.1k</span><span class=post-meta__separator>|</span><span>Reading time: 26 min</span></div></div></div></div><div class=layout id=content-inner><article id=post><div class=article-container id=post-content><h2 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h2><p>前段时间，我用<a href=https://github.com/SimulatedGREG/electron-vue>electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href=https://github.com/Molunerfinn/PicGo>PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。<p>预计将会从几篇系列文章或方面来展开：<ol><li><a href=https://molunerfinn.com/electron-vue-1/>electron-vue入门</a><li><a href=https://molunerfinn.com/electron-vue-2/>Main进程和Renderer进程的简单开发</a><li><a href=https://molunerfinn.com/electron-vue-3/>引入基于Lodash的JSON database——lowdb</a><li><a href=https://molunerfinn.com/electron-vue-4/>跨平台的一些兼容措施</a><li><a href=https://molunerfinn.com/electron-vue-5/>通过CI发布以及更新的方式</a><li><a href=https://molunerfinn.com/electron-vue-6/>开发插件系统——CLI部分</a><li><a href=https://molunerfinn.com/electron-vue-7/>开发插件系统——GUI部分</a><li>想到再写…</ol><h2 id=说明><a class=headerlink href=#说明 title=说明></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。<p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><span id=more></span><h2 id=Main进程和Renderer进程的基本认识><a class=headerlink href=#Main进程和Renderer进程的基本认识 title=Main进程和Renderer进程的基本认识></a>Main进程和Renderer进程的基本认识</h2><p>从上一篇文章结尾部分我们运行成功的一个electron-vue的<a href=https://molunerfinn.com/electron-vue-1/#electron-vue%E5%AE%89%E8%A3%85>DEMO</a>来直观看看这两个进程的粗浅认识：<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnh28jgs8nj20ms098wge><p>可以看到Main进程管理的是这个app窗口（<a href=https://electronjs.org/docs/api/browser-window>BrowserWindow</a>），而Renderer进程负责的就是我们熟悉的页面UI渲染。不过实际上，它们远远不仅如此。下面一张图能够把它们所支持、管理的electron或者原生的模块大致列出来：<p><img alt="main & renderer process tree" src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnhcn82n7sj21wu1fmn6v><blockquote><p>图中列出来的大部分模块都是我们会在开发过程中用到的。</blockquote><p>它们有各自的模块，也有共有的模块比如<code>clipboard</code>等。还有一部分是Main进程里的模块，不过可以通过<code>remote</code>模块，让renderer进程也能使用。比如<code>Menu</code>比如<code>shell</code>等。<p>了解一下哪些模块在哪些进程里，哪些模块可以通过<code>remote</code>模块让renderer进程也能使用是有必要的，这样我们后续开发的时候才能正确的使用。<p>上面的模块可能有些从名字里并不能看出作用是啥，没关系，后续的内容会慢慢涉及。<h2 id=Main进程开发><a class=headerlink href=#Main进程开发 title=Main进程开发></a>Main进程开发</h2><p>上面说到了Main进程一个显著的作用就是创建app的窗口。我们来看看这个是怎么实现的。<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { app, <span class="title class_">BrowserWindow</span> } <span class=keyword>from</span> <span class=string>'electron'</span> <span class=comment>// 从electron引入app和BrowserWindow</span></span><br><span class=line></span><br><span class=line><span class=keyword>let</span> mainWindow</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> winURL = process.<span class=property>env</span>.<span class=property>NODE_ENV</span> === <span class=string>'development'</span></span><br><span class=line>  ? <span class=string>`http://localhost:9080`</span> <span class=comment>// 开发模式的话走webpack-dev-server的url</span></span><br><span class=line>  : <span class=string>`file://<span class=subst>${__dirname}</span>/index.html`</span></span><br><span class=line></span><br><span class=line><span class=keyword>function</span> <span class="title function_">createWindow</span> (<span class=params></span>) { <span class=comment>// 创建窗口</span></span><br><span class=line>  <span class=comment>/**</span></span><br><span class=line><span class=comment>   * Initial window options</span></span><br><span class=line><span class=comment>   */</span></span><br><span class=line>  mainWindow = <span class=keyword>new</span> <span class="title class_">BrowserWindow</span>({</span><br><span class=line>    <span class=attr>height</span>: <span class=number>563</span>,</span><br><span class=line>    <span class=attr>useContentSize</span>: <span class=literal>true</span>,</span><br><span class=line>    <span class=attr>width</span>: <span class=number>1000</span></span><br><span class=line>  }) <span class=comment>// 创建一个窗口</span></span><br><span class=line></span><br><span class=line>  mainWindow.<span class="title function_">loadURL</span>(winURL) <span class=comment>// 加载窗口的URL -> 来自renderer进程的页面</span></span><br><span class=line></span><br><span class=line>  mainWindow.<span class="title function_">on</span>(<span class=string>'closed'</span>, <span class=function>() =></span> {</span><br><span class=line>    mainWindow = <span class=literal>null</span></span><br><span class=line>  })</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>app.<span class="title function_">on</span>(<span class=string>'ready'</span>, createWindow) <span class=comment>// app准备好的时候创建窗口</span></span><br></pre></table></figure><p>暂且先不管渲染进程里的页面长什么样，在app准备好的时候打开一个窗口只需要调用一个创建<code>BrowserWindow</code>的方法即可。<p>main进程里的开发有点当年写<code>jQuery</code>的样子，比较多的是事件驱动型的写法。<h3 id=app><a class=headerlink href=#app title=app></a>app</h3><p>首先需要注意的是<a href=https://electronjs.org/docs/api/app>app</a>的模块。这个模块是electron应用的骨架。它掌管着整个应用的生命周期钩子，以及很多其他事件钩子。<p>app的常用生命周期钩子如下：<ul><li><code>will-finish-launching</code> 在应用完成基本启动进程之后触发<li><code>ready</code> 当electron完成初始化后触发<li><code>window-all-closed</code> 所有窗口都关闭的时候触发，在windows和linux里，所有窗口都退出的时候<strong>通常</strong>是应用退出的时候<li><code>before-quit</code> 退出应用之前的时候触发<li><code>will-quit</code> 即将退出应用的时候触发<li><code>quit</code> 应用退出的时候触发</ul><p>而我们通常会在<code>ready</code>的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在<code>will-quit</code>或者<code>quit</code>的时候执行一些清空操作，比如解绑应用快捷键。<p>特别的，在非<code>macOS</code>的系统下，通常一个应用的所有窗口都退出的时候，也是这个应用退出之时。所以可以配合<code>window-all-closed</code>这个钩子来实现：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>app.<span class="title function_">on</span>(<span class=string>'window-all-closed'</span>, <span class=function>() =></span> {</span><br><span class=line>  <span class=keyword>if</span> (process.<span class=property>platform</span> !== <span class=string>'darwin'</span>) { <span class=comment>// 当操作系统不是darwin（macOS）的话</span></span><br><span class=line>    app.<span class="title function_">quit</span>() <span class=comment>// 退出应用</span></span><br><span class=line>  }</span><br><span class=line>})</span><br></pre></table></figure><p>除了上面说的生命周期钩子之外，还有一些常用的事件钩子：<ul><li><code>active</code>（仅macOS）当应用处于激活状态时<li><code>browser-window-created</code> 当一个BrowserWindow被创建的时候<li><code>browser-window-focus</code> 当一个BrowserWindow处于激活状态的时候</ul><p>这些钩子需要配合一些具体场景来做出具体的操作。比如当一个BrowserWindow处于激活状态的时候修改窗口的title值。<p>当然，app这个模块除了上述的一些事件钩子之外，还有一些很常用的方法：<ul><li><code>app.quit()</code> 用于退出应用<li><code>app.getPath(name)</code> 用于获取一些系统目录，对于存放应用的配置文件等很有用<li><code>app.focus()</code> 用于激活应用，不同系统激活逻辑<a href=https://electronjs.org/docs/api/app#appfocus>不一样</a></ul><p>这些事件和方法都是怎么知道的呢？当然是<a href=https://electronjs.org/docs/>官方文档</a>了。不过并不需要一开始就通读一遍官方的api文档。官方的api文档更多的作用是用来查阅，当你要开发到某个功能的时候再去查它能否有对应的api、怎么使用。<h3 id=BrowserWindow><a class=headerlink href=#BrowserWindow title=BrowserWindow></a>BrowserWindow</h3><p>BrowserWindow模块用于创建最常见的应用窗口。对于不同系统，创建的窗口的默认样式也不太一样。下面来看看macOS和windows的窗口在外观上的区别：<p>mac版的<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fncs5yv0qdj21jk0wi44h><p>windows版的<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnhdibuabmj20rq0h2whl><p>可以看到二者在窗口顶部的操作区（最小化、最大化、关闭）和标题的位置以及菜单的位置还是有明显的不同的。它们跟系统原生的窗口是一致的。不过如果你想要美化一下也是没问题的。比如：<p>mac版的PicGo<p><img alt=picgo-mac src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnhdaimi40j218g0p0dic><p>和windows的PicGo<p><img alt=picgo-windows src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnhdb9mj1uj20m80ci3yz><p>其中mac版用了系统的操作区，而windows则没有用系统的操作区，而是用图标模拟的。不过同样的地方是都未使用系统默认的<code>titlebar</code>。这个之后会结合<code>renderer</code>进程来说。<p>让我们来看看创建一个BrowserWindow的常用配置：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>let</span> <span class="variable language_">window</span></span><br><span class=line></span><br><span class=line><span class=keyword>function</span> <span class="title function_">createWindow</span> (<span class=params></span>) {</span><br><span class=line>  <span class="variable language_">window</span> = <span class=keyword>new</span> <span class="title class_">BrowserWindow</span>({</span><br><span class=line>    <span class=attr>height</span>: <span class=number>900</span>, <span class=comment>// 高</span></span><br><span class=line>    <span class=attr>width</span>: <span class=number>400</span>, <span class=comment>// 宽</span></span><br><span class=line>    <span class=attr>show</span>: <span class=literal>false</span>, <span class=comment>// 创建后是否显示</span></span><br><span class=line>    <span class=attr>frame</span>: <span class=literal>false</span>, <span class=comment>// 是否创建frameless窗口</span></span><br><span class=line>    <span class=attr>fullscreenable</span>: <span class=literal>false</span>, <span class=comment>// 是否允许全屏</span></span><br><span class=line>    <span class=attr>center</span>: <span class=literal>true</span>, <span class=comment>// 是否出现在屏幕居中的位置</span></span><br><span class=line>    <span class=attr>backgroundColor</span>: <span class=string>'#fff'</span> <span class=comment>// 背景色，用于transparent和frameless窗口</span></span><br><span class=line>    <span class=attr>titleBarStyle</span>: <span class=string>'xxx'</span> <span class=comment>// 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等</span></span><br><span class=line>    <span class=attr>resizable</span>: <span class=literal>false</span>, <span class=comment>// 是否允许拉伸大小</span></span><br><span class=line>    <span class=attr>transparent</span>: <span class=literal>true</span>, <span class=comment>// 是否是透明窗口（仅macOS）</span></span><br><span class=line>    <span class=attr>vibrancy</span>: <span class=string>'ultra-dark'</span>, <span class=comment>// 窗口模糊的样式（仅macOS）</span></span><br><span class=line>    <span class=attr>webPreferences</span>: {</span><br><span class=line>      <span class=attr>backgroundThrottling</span>: <span class=literal>false</span> <span class=comment>// 当页面被置于非激活窗口的时候是否停止动画和计时器</span></span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ... 以及其他可选配置</span></span><br><span class=line>  })</span><br><span class=line></span><br><span class=line>  <span class="variable language_">window</span>.<span class="title function_">loadURL</span>(url)</span><br><span class=line></span><br><span class=line>  <span class="variable language_">window</span>.<span class="title function_">on</span>(<span class=string>'closed'</span>, <span class=function>() =></span> { <span class="variable language_">window</span> = <span class=literal>null</span> })</span><br><span class=line>}</span><br></pre></table></figure><p>窗口的长宽自然不必说，需要指定。其中需要注意的几个比较重要的就是，<code>frame</code>这个选项，默认是<code>true</code>。如果选择了<code>false</code>则会创建一个<code>frameless</code><a href=https://electronjs.org/docs/api/frameless-window>窗口</a>，创建一个没有顶部工具栏、没有border的窗口。这个也是我们在windows系统下自定义顶部栏的基础。<p>像上述PicGo的主窗口的配置，就是通过如下的配置实现的：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class="title function_">createSettingWindow</span> = (<span class=params></span>) => {</span><br><span class=line>  <span class=keyword>const</span> options = {</span><br><span class=line>    <span class=attr>height</span>: <span class=number>450</span>,</span><br><span class=line>    <span class=attr>width</span>: <span class=number>800</span>,</span><br><span class=line>    <span class=attr>show</span>: <span class=literal>false</span>,</span><br><span class=line>    <span class=attr>frame</span>: <span class=literal>true</span>,</span><br><span class=line>    <span class=attr>center</span>: <span class=literal>true</span>,</span><br><span class=line>    <span class=attr>fullscreenable</span>: <span class=literal>false</span>,</span><br><span class=line>    <span class=attr>resizable</span>: <span class=literal>false</span>,</span><br><span class=line>    <span class=attr>title</span>: <span class=string>'PicGo'</span>,</span><br><span class=line>    <span class=attr>vibrancy</span>: <span class=string>'ultra-dark'</span>,</span><br><span class=line>    <span class=attr>transparent</span>: <span class=literal>true</span>,</span><br><span class=line>    <span class=attr>titleBarStyle</span>: <span class=string>'hidden'</span>,</span><br><span class=line>    <span class=attr>webPreferences</span>: {</span><br><span class=line>      <span class=attr>backgroundThrottling</span>: <span class=literal>false</span></span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>if</span> (process.<span class=property>platform</span> === <span class=string>'win32'</span>) { <span class=comment>// 针对windows平台做出不同的配置</span></span><br><span class=line>    options.<span class=property>show</span> = <span class=literal>true</span> <span class=comment>// 创建即展示</span></span><br><span class=line>    options.<span class=property>frame</span> = <span class=literal>false</span> <span class=comment>// 创建一个frameless窗口</span></span><br><span class=line>    options.<span class=property>backgroundColor</span> = <span class=string>'#3f3c37'</span> <span class=comment>// 背景色</span></span><br><span class=line>  }</span><br><span class=line>  settingWindow = <span class=keyword>new</span> <span class="title class_">BrowserWindow</span>(options)</span><br><span class=line></span><br><span class=line>  settingWindow.<span class="title function_">loadURL</span>(settingWinURL)</span><br><span class=line></span><br><span class=line>  settingWindow.<span class="title function_">on</span>(<span class=string>'closed'</span>, <span class=function>() =></span> {</span><br><span class=line>    settingWindow = <span class=literal>null</span></span><br><span class=line>  })</span><br><span class=line>}</span><br></pre></table></figure><p>跟<code>app</code>模块一样，<code>BrowserWindow</code>也有很多常用的事件钩子：<ul><li><code>closed</code> 当窗口被关闭的时候<li><code>focus</code> 当窗口被激活的时候<li><code>show</code> 当窗口展示的时候<li><code>hide</code> 当窗口被隐藏的时候<li><code>maxmize</code> 当窗口最大化时<li><code>minimize</code> 当窗口最小化时<li><code>...</code></ul><p>当然，也依然有很多实用的方法：<ul><li><code>BrowserWindow.getFocusedWindow()</code> [静态方法]获取激活的窗口<li><code>win.close()</code> [实例方法，下同]关闭窗口<li><code>win.focus()</code> 激活窗口<li><code>win.show()</code> 显示窗口<li><code>win.hide()</code> 隐藏窗口<li><code>win.maximize()</code> 最大化窗口<li><code>win.minimize()</code> 最小化窗口<li><code>win.restore()</code> 从最小化窗口恢复<li><code>...</code></ul><p>针对不同的业务逻辑你需要对窗口进行不一样的操作。这个需要跟你的项目需求相匹配。比如上述说到的，windows的顶部的操作区（放大、缩小、关闭按钮）就可以通过icon模拟+实例方法来实现。<h3 id=Tray><a class=headerlink href=#Tray title=Tray></a>Tray</h3><p>一开始看这个名字你可能并不知道这个是个什么东西。可以把它理解为不同系统的任务栏里的图标组件吧。<p>比如在macOS里，<code>Tray</code>配合上图标之后就是顶部栏里的应用图标了：<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnijxxj5gkj215i01at9b><p>比如在windows里，<code>Tray</code>配合上图标之后就是windows右下角的应用图标了：<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnijzo4hgbj20gl016a9z><p>需要注意的是，windows和macOS里，图标的大小都是<code>16*16</code>px。macOS下顶部栏的图标通常都是走<code>黑白</code>路线，所以可以为两种系统分别准备不同的图标。<code>PicGo</code>里<code>Tray</code>的生成代码大致如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>function</span> <span class="title function_">createTray</span> (<span class=params></span>) {</span><br><span class=line>  <span class=keyword>const</span> menubarPic = process.<span class=property>platform</span> === <span class=string>'darwin'</span> ? <span class=string>`<span class=subst>${__static}</span>/menubar.png`</span> : <span class=string>`<span class=subst>${__static}</span>/menubar-nodarwin.png`</span></span><br><span class=line>  tray = <span class=keyword>new</span> <span class="title class_">Tray</span>(menubarPic) <span class=comment>// 指定图片的路径</span></span><br><span class=line>  <span class=comment>// ... 其他代码</span></span><br><span class=line>}</span><br></pre></table></figure><p>注意上述代码里有一个<code>${__static}</code>的变量。该变量是<code>electron-vue</code>为我们暴露出来的项目根目录下的<code>static</code>文件夹的路径。通过这个路径，在开发和生产阶段都能很好的定位你的静态资源所在的目录。是个很方便的变量。<p>当然<code>Tray</code>并不只是一个图标而无其他作用了。Tray支持很多有用的事件。其中最关键的两个是<code>click</code>和<code>right-click</code>。分别对应鼠标左键点击和鼠标右键点击事件。<h4 id=鼠标左键点击事件><a class=headerlink href=#鼠标左键点击事件 title=鼠标左键点击事件></a>鼠标左键点击事件</h4><ul><li>在macOS系统下，鼠标左键点击Tray的icon可能会出现配置菜单，也有可能会出现应用窗口。<li>在windows下，鼠标左键点击Tray的icon通常会出现应用的窗口。</ul><h4 id=鼠标右键点击事件><a class=headerlink href=#鼠标右键点击事件 title=鼠标右键点击事件></a>鼠标右键点击事件</h4><ul><li>在macOS系统下，鼠标右键点击Tray的icon通常会出现配置菜单。<li>在windows系统下，同上。</ul><p>所以需要我们去适配不同操作系统下用户的操作习惯。<p>对应于PicGo而言，在macOS系统下左键点击会出现一个menubar的小窗口，右键点击会出现配置菜单。而在windows下，左键点击会直接出现主窗口，（因为在windows下无小窗口的必要），右键点击会出现配置菜单。它们在PicGo里的实现如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>function</span> <span class="title function_">createTray</span> (<span class=params></span>) {</span><br><span class=line>  <span class=keyword>const</span> menubarPic = process.<span class=property>platform</span> === <span class=string>'darwin'</span> ? <span class=string>`<span class=subst>${__static}</span>/menubar.png`</span> : <span class=string>`<span class=subst>${__static}</span>/menubar-nodarwin.png`</span></span><br><span class=line>  tray = <span class=keyword>new</span> <span class="title class_">Tray</span>(menubarPic)</span><br><span class=line>  <span class=keyword>const</span> contextMenu = <span class=comment>// ...菜单</span></span><br><span class=line>  tray.<span class="title function_">on</span>(<span class=string>'right-click'</span>, <span class=function>() =></span> { <span class=comment>// 右键点击</span></span><br><span class=line>    <span class="variable language_">window</span>.<span class="title function_">hide</span>() <span class=comment>// 隐藏小窗口</span></span><br><span class=line>    tray.<span class="title function_">popUpContextMenu</span>(contextMenu) <span class=comment>// 打开菜单</span></span><br><span class=line>  })</span><br><span class=line>  tray.<span class="title function_">on</span>(<span class=string>'click'</span>, <span class=function>() =></span> { <span class=comment>// 左键点击</span></span><br><span class=line>    <span class=keyword>if</span> (process.<span class=property>platform</span> === <span class=string>'darwin'</span>) { <span class=comment>// 如果是macOS</span></span><br><span class=line>      <span class="title function_">toggleWindow</span>() <span class=comment>// 打开或关闭小窗口</span></span><br><span class=line>    } <span class=keyword>else</span> { <span class=comment>// 如果是windows</span></span><br><span class=line>      <span class="variable language_">window</span>.<span class="title function_">hide</span>() <span class=comment>// 隐藏小窗口</span></span><br><span class=line>      <span class=keyword>if</span> (settingWindow === <span class=literal>null</span>) { <span class=comment>// 如果主窗口不存在就创建一个</span></span><br><span class=line>        <span class="title function_">createSettingWindow</span>()</span><br><span class=line>        settingWindow.<span class="title function_">show</span>()</span><br><span class=line>      } <span class=keyword>else</span> { <span class=comment>// 如果主窗口在，就显示并激活</span></span><br><span class=line>        settingWindow.<span class="title function_">show</span>()</span><br><span class=line>        settingWindow.<span class="title function_">focus</span>()</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  })</span><br><span class=line>}</span><br></pre></table></figure><p>对于macOS而言，Tray还有一个很棒的特性——可以拖拽文件到Tray的icon上，会触发如下事件：<ul><li><code>drop</code> 当任何东西拖拽到icon上时<li><code>drop-files</code> 当文件被拖拽到icon上时<li><code>drop-text</code> 当文本被拖拽到icon上时<li><code>drop-enter</code> 当刚拖拽到icon上时<li><code>drop-leave</code> 当拖拽事件离开icon时<li><code>drop-end</code> 当拖拽事件结束时</ul><p>就像PicGo实现的拖拽图片到Tray的icon上时实现图片上传的功能，就是用到了上述的一些事件：<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif><p>尤其注意到在拖拽上的时候和拖拽结束后的时候icon是不一样的。在PicGo里是这样实现的，很简单：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>tray.<span class="title function_">on</span>(<span class=string>'drag-enter'</span>, <span class=function>() =></span> {</span><br><span class=line>  tray.<span class="title function_">setImage</span>(<span class=string>`<span class=subst>${__static}</span>/upload.png`</span>)</span><br><span class=line>})</span><br><span class=line></span><br><span class=line>tray.<span class="title function_">on</span>(<span class=string>'drag-end'</span>, <span class=function>() =></span> {</span><br><span class=line>  tray.<span class="title function_">setImage</span>(<span class=string>`<span class=subst>${__static}</span>/menubar.png`</span>)</span><br><span class=line>})</span><br></pre></table></figure><p>而<code>Tray</code>另一个重要的作用就是开启菜单项。这个将结合下一节<code>Menu</code>一起说明。<h3 id=Menu><a class=headerlink href=#Menu title=Menu></a>Menu</h3><p>electron威力强大的Menu组件，既能够生成系统菜单项，也能实现绑定应用常用快捷键的功能。<p>先来看看什么是系统菜单项：<blockquote><p>macOS</blockquote><p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnisjmm1f9j213m074wln><blockquote><p>windows</blockquote><p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnisory5p4j215c0pen3z><p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnislgodz9j204k047mx8><p>主要分两种。<ul><li>第一种是app的菜单。对于macOS来说就是顶部栏左侧区域的菜单项。对于windows而言就是一个窗口的标题栏下方的菜单区。<li>第二种是类似于右键菜单的菜单。</ul><p>第一种菜单可以通过<code>Menu.setApplicationMenu()</code>来实现。<p>第二种菜单可以通过两个步骤来展示：<p><strong>1.</strong> 创建菜单：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> contextMenu = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>([...])</span><br></pre></table></figure><p><strong>2.</strong> 展示菜单：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>tray.<span class="title function_">on</span>(<span class=string>'right-click'</span>, <span class=function>() =></span> { <span class=comment>// 右键点击tray的时候</span></span><br><span class=line>  tray.<span class="title function_">popUpContextMenu</span>(contextMenu) <span class=comment>// 弹出菜单</span></span><br><span class=line>})</span><br></pre></table></figure><p>这里我们只介绍了<code>Menu</code>本身。其实组成<code>Menu</code>的是一个一个的<code>MenuItem</code>。它们有很多类型：<ol><li>normal<li>separator<li>submenu<li>checkbox<li>radio</ol><p>以及很多角色：<ol><li>quit<li>copy<li>redo<li>undo<li>minimize<li>close<li>reload<li>…</ol><p>通常来说，配置的菜单项基本从类型里来组合。比如PicGo的菜单项：<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnivun40bij20fg082wgo><p>这里面就有normal、submenu、checkbox和radio四种类型。其中默认是normal。<p>角色的话通常对应的是一些常见的行为。比如<code>quit</code>是退出app，比如<code>minimize</code>是最小化，比如<code>copy</code>是复制。不过需要注意的是，如果你没有在创建app菜单里指定这些操作的快捷键的话，那么一些常见的快捷操作就无法在你的app里使用了。比如<code>ctrl+c</code>或者<code>command+c</code>复制这个操作，如果你没有通过<code>Menu.setApplicationMenu()</code>来设定这个快捷键的话，那么在你的electron应用里就无法执行复制的操作了。PicGo在早期版本里也犯了这个<a href>错误</a>。当时的问题是我在开发模式下是没有问题的，但是在生产模式下就无法进行复制粘贴操作。后来查了一下原因，发现原来在开发模式下，electron会置入默认的一些快捷操作菜单，如图：<p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnjcaoo0btj20pg0fcah1><p>所以在生产模式如果我没有置入这些快捷键的话，使用者就无法使用了。<strong>这个是大坑</strong>。<p>说了这么多，来看看生成app的菜单的代码长啥样：<blockquote><p>注意，如果在开发模式下直接只使用如下快捷键的话，一些调试快捷键比如<code>F12</code>或者<code>command+shift+i</code>打开控制台的操作就无法使用了。所以在开发模式下不需要创建这些快捷键菜单。</blockquote><figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class="title function_">createMenu</span> = (<span class=params></span>) => {</span><br><span class=line>  <span class=keyword>if</span> (process.<span class=property>env</span>.<span class=property>NODE_ENV</span> !== <span class=string>'development'</span>) {</span><br><span class=line>    <span class=keyword>const</span> template = [{</span><br><span class=line>      <span class=attr>label</span>: <span class=string>'Edit'</span>,</span><br><span class=line>      <span class=attr>submenu</span>: [</span><br><span class=line>        { <span class=attr>label</span>: <span class=string>'Undo'</span>, <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+Z'</span>, <span class=attr>selector</span>: <span class=string>'undo:'</span> },</span><br><span class=line>        { <span class=attr>label</span>: <span class=string>'Redo'</span>, <span class=attr>accelerator</span>: <span class=string>'Shift+CmdOrCtrl+Z'</span>, <span class=attr>selector</span>: <span class=string>'redo:'</span> },</span><br><span class=line>        { <span class=attr>type</span>: <span class=string>'separator'</span> },</span><br><span class=line>        { <span class=attr>label</span>: <span class=string>'Cut'</span>, <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+X'</span>, <span class=attr>selector</span>: <span class=string>'cut:'</span> },</span><br><span class=line>        { <span class=attr>label</span>: <span class=string>'Copy'</span>, <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+C'</span>, <span class=attr>selector</span>: <span class=string>'copy:'</span> },</span><br><span class=line>        { <span class=attr>label</span>: <span class=string>'Paste'</span>, <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+V'</span>, <span class=attr>selector</span>: <span class=string>'paste:'</span> },</span><br><span class=line>        { <span class=attr>label</span>: <span class=string>'Select All'</span>, <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+A'</span>, <span class=attr>selector</span>: <span class=string>'selectAll:'</span> },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>label</span>: <span class=string>'Quit'</span>,</span><br><span class=line>          <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+Q'</span>,</span><br><span class=line>          <span class="title function_">click</span> () {</span><br><span class=line>            app.<span class="title function_">quit</span>()</span><br><span class=line>          }</span><br><span class=line>        }</span><br><span class=line>      ]</span><br><span class=line>    }]</span><br><span class=line>    menu = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>(template)</span><br><span class=line>    <span class="title class_">Menu</span>.<span class="title function_">setApplicationMenu</span>(menu)</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>可以通过<code>accelerator</code>指定你想要的快捷键。诸如<code>Shift</code>、<code>Ctrl</code>、<code>Cmd</code>等键位缩写。如果是组合键，就加上<code>+</code>。尤其注意到，因为macOS和windows键位的差异，所以有一个很好用的键位缩写<code>CmdOrCtrl</code>，即如果是在macOS上就是<code>Cmd</code>，在windows上就是<code>Ctrl</code>。<p>然后再来看看Tray的“右键”菜单的生成：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> contextMenu = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>([</span><br><span class=line>   {</span><br><span class=line>     <span class=attr>label</span>: <span class=string>'关于'</span>,</span><br><span class=line>     <span class="title function_">click</span> () {</span><br><span class=line>       dialog.<span class="title function_">showMessageBox</span>({</span><br><span class=line>         <span class=attr>title</span>: <span class=string>'PicGo'</span>,</span><br><span class=line>         <span class=attr>message</span>: <span class=string>'PicGo'</span>,</span><br><span class=line>         <span class=attr>detail</span>: <span class=string>`Version: <span class=subst>${pkg.version}</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class=line>       })</span><br><span class=line>     }</span><br><span class=line>   },</span><br><span class=line>   {</span><br><span class=line>     <span class=attr>label</span>: <span class=string>'打开详细窗口'</span>,</span><br><span class=line>     <span class="title function_">click</span> () {</span><br><span class=line>       <span class=keyword>if</span> (settingWindow === <span class=literal>null</span>) {</span><br><span class=line>         <span class="title function_">createSettingWindow</span>()</span><br><span class=line>         settingWindow.<span class="title function_">show</span>()</span><br><span class=line>       } <span class=keyword>else</span> {</span><br><span class=line>         settingWindow.<span class="title function_">show</span>()</span><br><span class=line>         settingWindow.<span class="title function_">focus</span>()</span><br><span class=line>       }</span><br><span class=line>     }</span><br><span class=line>   },</span><br><span class=line>   {</span><br><span class=line>     <span class=attr>label</span>: <span class=string>'选择默认图床'</span>,</span><br><span class=line>     <span class=attr>type</span>: <span class=string>'submenu'</span>,</span><br><span class=line>     <span class=attr>submenu</span>: [</span><br><span class=line>       {</span><br><span class=line>         <span class=attr>label</span>: <span class=string>'微博图床'</span>,</span><br><span class=line>         <span class=attr>type</span>: <span class=string>'radio'</span>,</span><br><span class=line>         <span class=attr>checked</span>: db.<span class="title function_">read</span>().<span class="title function_">get</span>(<span class=string>'picBed.current'</span>).<span class="title function_">value</span>() === <span class=string>'weibo'</span>,</span><br><span class=line>         <span class="title function_">click</span> () {</span><br><span class=line>           db.<span class="title function_">read</span>().<span class="title function_">set</span>(<span class=string>'picBed.current'</span>, <span class=string>'weibo'</span>)</span><br><span class=line>             .<span class="title function_">write</span>()</span><br><span class=line>         }</span><br><span class=line>       },</span><br><span class=line>       {</span><br><span class=line>         <span class=attr>label</span>: <span class=string>'七牛图床'</span>,</span><br><span class=line>         <span class=attr>type</span>: <span class=string>'radio'</span>,</span><br><span class=line>         <span class=attr>checked</span>: db.<span class="title function_">read</span>().<span class="title function_">get</span>(<span class=string>'picBed.current'</span>).<span class="title function_">value</span>() === <span class=string>'qiniu'</span>,</span><br><span class=line>         <span class="title function_">click</span> () {</span><br><span class=line>           db.<span class="title function_">read</span>().<span class="title function_">set</span>(<span class=string>'picBed.current'</span>, <span class=string>'qiniu'</span>)</span><br><span class=line>             .<span class="title function_">write</span>()</span><br><span class=line>         }</span><br><span class=line>       },</span><br><span class=line>       {</span><br><span class=line>         <span class=attr>label</span>: <span class=string>'腾讯云COS'</span>,</span><br><span class=line>         <span class=attr>type</span>: <span class=string>'radio'</span>,</span><br><span class=line>         <span class=attr>checked</span>: db.<span class="title function_">read</span>().<span class="title function_">get</span>(<span class=string>'picBed.current'</span>).<span class="title function_">value</span>() === <span class=string>'tcyun'</span>,</span><br><span class=line>         <span class="title function_">click</span> () {</span><br><span class=line>           db.<span class="title function_">read</span>().<span class="title function_">set</span>(<span class=string>'picBed.current'</span>, <span class=string>'tcyun'</span>)</span><br><span class=line>             .<span class="title function_">write</span>()</span><br><span class=line>         }</span><br><span class=line>       },</span><br><span class=line>       {</span><br><span class=line>         <span class=attr>label</span>: <span class=string>'又拍云图床'</span>,</span><br><span class=line>         <span class=attr>type</span>: <span class=string>'radio'</span>,</span><br><span class=line>         <span class=attr>checked</span>: db.<span class="title function_">read</span>().<span class="title function_">get</span>(<span class=string>'picBed.current'</span>).<span class="title function_">value</span>() === <span class=string>'upyun'</span>,</span><br><span class=line>         <span class="title function_">click</span> () {</span><br><span class=line>           db.<span class="title function_">read</span>().<span class="title function_">set</span>(<span class=string>'picBed.current'</span>, <span class=string>'upyun'</span>)</span><br><span class=line>             .<span class="title function_">write</span>()</span><br><span class=line>         }</span><br><span class=line>       }</span><br><span class=line>     ]</span><br><span class=line>   },</span><br><span class=line>   {</span><br><span class=line>     <span class=attr>label</span>: <span class=string>'打开更新助手'</span>,</span><br><span class=line>     <span class=attr>type</span>: <span class=string>'checkbox'</span>,</span><br><span class=line>     <span class=attr>checked</span>: db.<span class="title function_">get</span>(<span class=string>'picBed.showUpdateTip'</span>).<span class="title function_">value</span>(),</span><br><span class=line>     <span class="title function_">click</span> () {</span><br><span class=line>       <span class=keyword>const</span> value = db.<span class="title function_">read</span>().<span class="title function_">get</span>(<span class=string>'picBed.showUpdateTip'</span>).<span class="title function_">value</span>()</span><br><span class=line>       db.<span class="title function_">read</span>().<span class="title function_">set</span>(<span class=string>'picBed.showUpdateTip'</span>, !value).<span class="title function_">write</span>()</span><br><span class=line>     }</span><br><span class=line>   },</span><br><span class=line>   {</span><br><span class=line>     <span class=attr>role</span>: <span class=string>'quit'</span>,</span><br><span class=line>     <span class=attr>label</span>: <span class=string>'退出'</span></span><br><span class=line>   }</span><br><span class=line> ])</span><br><span class=line></span><br><span class=line> tray.<span class="title function_">on</span>(<span class=string>'right-click'</span>, <span class=function>() =></span> {</span><br><span class=line>   tray.<span class="title function_">popUpContextMenu</span>(contextMenu)</span><br><span class=line> })</span><br></pre></table></figure><p>注意，菜单项的点击事件可以直接通过<code>click</code>属性来指定。上面我们是先通过了<code>Menu.buildFromTemplate()</code>这个方法创建了菜单，然后再在右键点击<code>Tray</code>图标的时候将其弹（PopUp)出来。<p>当然也有其他构建菜单的方法。可以通过Menu实例的<code>append</code>方法来加入<code>Menu Item</code>。如下例：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> menu = <span class=keyword>new</span> <span class="title class_">Menu</span>()</span><br><span class=line>menu.<span class="title function_">append</span>(<span class=keyword>new</span> <span class="title class_">MenuItem</span>({ <span class=attr>label</span>: <span class=string>'Cut'</span>, <span class=attr>accelerator</span>: <span class=string>'CmdOrCtrl+X'</span> }))</span><br><span class=line>menu.<span class="title function_">append</span>(<span class=keyword>new</span> <span class="title class_">MenuItem</span>({ <span class=attr>type</span>: <span class=string>'separator'</span> })) <span class=comment>// 分割线</span></span><br><span class=line>menu.<span class="title function_">append</span>(<span class=keyword>new</span> <span class="title class_">MenuItem</span>({ <span class=attr>label</span>: <span class=string>'Helper'</span>, <span class=attr>type</span>: <span class=string>'checkbox'</span>, <span class=attr>checked</span>: <span class=literal>true</span> }))</span><br></pre></table></figure><p>基本上有了上述的几个基本模块，我们的一个应用的骨架是基本搭建好了，拥有窗口、任务栏应用图标和菜单项。其他的Main进程的模块，并不是必须的，当会用到的时候将在之后的文章里逐步提及。下一节我们将来看renderer进程的开发。<h2 id=Renderer进程开发><a class=headerlink href=#Renderer进程开发 title=Renderer进程开发></a>Renderer进程开发</h2><p>对于<code>electron-vue</code>而言，renderer进程其实大部分就是在写我们平时常写的前端页面罢了。不过相对于平时在浏览器里写的页面，在electron里写页面的时候你还能用到不少非浏览器端的模块，比如<code>fs</code>，比如electron通过<code>remote</code>模块暴露给renderer进程的模块。接下去我们来看看renderer进程有哪些需要注意的地方。<h3 id=请使用Hash模式><a class=headerlink href=#请使用Hash模式 title=请使用Hash模式></a>请使用Hash模式</h3><p>往常我们在写Vue的时候都比较喜欢开启路由的<code>history</code>模式，因为这样在浏览器的地址栏上看起来比较好看——没有hash的<code>#</code>号，就如同请求后端的url一般。然而需要注意的是，<code>history</code>模式需要后端服务器的支持。<p>可能很多朋友平时开发的时候没有感觉，那是因为vue-cli里在开发模式下启动的<code>webpack-dev-server</code>帮你实现了服务端的<code>history-fallback</code>的特性。所以在实际部署的时候，至少都需要在你的web服务器程序诸如<code>nginx</code>、<code>apache</code>等配置相关的规则，让前端路由返回给<code>vue-router</code>去处理。<p>而electron里也是如此。在开发模式下，由于使用的是<code>webpack-dev-server</code>开启的服务器，所以<code>BrowserWindow</code>加载的是来自于类似<code>http://localhost:9080</code>这样的地址的页面。而在生产模式下，却是使用的<code>file://</code>的协议，比如<code>file://${__dirname}/index.html</code>来指定窗口加载的页面。<p>因此，从上面的表述你也能明白了。假如我有一个子路由地址为<code>child</code>。如果不启用Hash模式，在开发模式下没啥问题，<code>http://localhost:9080/child</code>，但是在生产模式下，<code>file://${__dirname}/index.html/child</code>却是无法匹配的一条路径。因此在electron下，<code>vue-router</code>请不要使用<code>history</code>模式，而使用默认的<code>hash</code>模式。<p>那么上面的问题就迎刃而解，变为<code>file://${__dirname}/index.html#child</code>即可。<p>PicGo里加载的页面路由规则如下，从中你也能看出我使用的是<code>hash</code>模式。<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> winURL = process.<span class=property>env</span>.<span class=property>NODE_ENV</span> === <span class=string>'development'</span></span><br><span class=line>  ? <span class=string>`http://localhost:9080`</span></span><br><span class=line>  : <span class=string>`file://<span class=subst>${__dirname}</span>/index.html`</span></span><br><span class=line><span class=keyword>const</span> settingWinURL = process.<span class=property>env</span>.<span class=property>NODE_ENV</span> === <span class=string>'development'</span></span><br><span class=line>  ? <span class=string>`http://localhost:9080/#setting/upload`</span></span><br><span class=line>  : <span class=string>`file://<span class=subst>${__dirname}</span>/index.html#setting/upload`</span></span><br></pre></table></figure><h3 id=实现自己的titlebar><a class=headerlink href=#实现自己的titlebar title=实现自己的titlebar></a>实现自己的titlebar</h3><p>在上面讲<code>BrowserWindow</code>的时候，我说到有时为了应用的美观，并不想让我们的应用窗口采用系统默认的<code>titlebar</code>，而想用自己写的来实现。这样的话就在创建你的<code>BrowserWindow</code>的配置里加上一句<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>titleBarStyle</span>: <span class=string>'hidden'</span></span><br></pre></table></figure><p>这样就行了。然后你就可以自行在renderer进程的页面里模拟一个顶部的<code>titlebar</code>了，比如上面提到的<code>PicGo</code>的<code>titlebar</code>的样子。实际上代码也很简单：<figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag>&lt;<span class=name>div</span> <span class=attr>class</span>=<span class=string>"fake-title-bar"</span>></span></span><br><span class=line>  PicGo - {{ version }}</span><br><span class=line>  <span class=tag>&lt;<span class=name>div</span> <span class=attr>class</span>=<span class=string>"handle-bar"</span> <span class=attr>v-if</span>=<span class=string>"os === 'win32'"</span>></span> <span class=comment>&lt;!-- 如果是windows系统 就加上模拟的操作按钮--></span></span><br><span class=line>    <span class=tag>&lt;<span class=name>i</span> <span class=attr>class</span>=<span class=string>"el-icon-minus"</span> @<span class=attr>click</span>=<span class=string>"minimizeWindow"</span>></span><span class=tag>&lt;/<span class=name>i</span>></span></span><br><span class=line>    <span class=tag>&lt;<span class=name>i</span> <span class=attr>class</span>=<span class=string>"el-icon-close"</span> @<span class=attr>click</span>=<span class=string>"closeWindow"</span>></span><span class=tag>&lt;/<span class=name>i</span>></span></span><br><span class=line>  <span class=tag>&lt;/<span class=name>div</span>></span></span><br><span class=line><span class=tag>&lt;/<span class=name>div</span>></span></span><br></pre></table></figure><p>然后把这个titlebar的position置顶即可。<p>不过在平时的使用中，我们要注意，一般我们鼠标按住titlebar的时候是可以拖动窗口的。但是如果我们在不加可拖拽的属性之前，我们自己写的titlebar是不具备这样的特性的。要加上这个特性也很简单：<figure class="highlight css"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=selector-class>.fake-title-bar</span> {</span><br><span class=line>  -webkit-app-region drag</span><br><span class=line>}</span><br></pre></table></figure><p>只需一条CSS，即可让你的titlebar可以拖拽。<p>不过在windows下，操作区的按钮（缩小、放大、关闭）长按应该是不能拖拽的，所以还需要：<figure class="highlight css"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=selector-class>.handle-bar</span> {</span><br><span class=line>  -webkit-app-region no-drag</span><br><span class=line>}</span><br></pre></table></figure><p>变成<code>no-drag</code>，这样就实现了我们自己生成应用的titlebar了。<h3 id=drag-drop的避免><a class=headerlink href=#drag-drop的避免 title=drag&drop的避免></a>drag&drop的避免</h3><p>通常我们用Chrome的时候，有个特性是比如你往Chrome里拖入一个pdf，它就会自动用内置的pdf阅读器打开。你往Chrome里拖入一张图片，它就会打开这张图片。由于我们的electron应用的<code>BrowserWindow</code>其实内部也是一个浏览器，所以这样的特性依然存在。而这也是很多人没有注意的地方。也就是当你开发完一个electron应用之后，往里拖入一张图片，一个pdf等等，如果不是一个可拖拽区域（比如PicGo的上传区），那么它就不应该打开这张图、这个pdf，而是将其排除在外。<p>所以我们将在全局监听<code>drag</code>和<code>drop</code>事件，当用户拖入一个文件但是又不是拖入可拖拽区域的时候，应该将其屏蔽掉。因为所有的页面都应该要有这样的特性，所以我写了一个vue的<code>mixin</code>：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>export</span> <span class=keyword>default</span> {</span><br><span class=line>  <span class="title function_">mounted</span> () {</span><br><span class=line>    <span class="variable language_">this</span>.<span class="title function_">disableDragEvent</span>()</span><br><span class=line>  },</span><br><span class=line>  <span class=attr>methods</span>: {</span><br><span class=line>    <span class="title function_">disableDragEvent</span> () {</span><br><span class=line>      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class=string>'dragenter'</span>, <span class="variable language_">this</span>.<span class=property>disableDrag</span>, <span class=literal>false</span>)</span><br><span class=line>      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class=string>'dragover'</span>, <span class="variable language_">this</span>.<span class=property>disableDrag</span>)</span><br><span class=line>      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class=string>'drop'</span>, <span class="variable language_">this</span>.<span class=property>disableDrag</span>)</span><br><span class=line>    },</span><br><span class=line>    <span class="title function_">disableDrag</span> (e) {</span><br><span class=line>      <span class=keyword>const</span> dropzone = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class=string>'upload-area'</span>) <span class=comment>// 这个是可拖拽的上传区</span></span><br><span class=line>      <span class=keyword>if</span> (dropzone === <span class=literal>null</span> || !dropzone.<span class="title function_">contains</span>(e.<span class=property>target</span>)) {</span><br><span class=line>        e.<span class="title function_">preventDefault</span>()</span><br><span class=line>        e.<span class=property>dataTransfer</span>.<span class=property>effectAllowed</span> = <span class=string>'none'</span></span><br><span class=line>        e.<span class=property>dataTransfer</span>.<span class=property>dropEffect</span> = <span class=string>'none'</span></span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  },</span><br><span class=line>  <span class="title function_">beforeDestroy</span> () {</span><br><span class=line>    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class=string>'dragenter'</span>, <span class="variable language_">this</span>.<span class=property>disableDrag</span>, <span class=literal>false</span>)</span><br><span class=line>    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class=string>'dragover'</span>, <span class="variable language_">this</span>.<span class=property>disableDrag</span>)</span><br><span class=line>    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class=string>'drop'</span>, <span class="variable language_">this</span>.<span class=property>disableDrag</span>)</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>这样在全局引入这个mixin即可。<h3 id=remote模块的使用><a class=headerlink href=#remote模块的使用 title=remote模块的使用></a>remote模块的使用</h3><p>remote模块是electron为了让一些原本在Main进程里运行的模块也能在renderer进程里运行而创建的。以下说几个我们会用到的。<p>在<code>electron-vue</code>里内置了<code>vue-electron</code>这个模块，可以在vue里很方便的使用诸如<code>this.$electron.remote.xxx</code>来使用remote的模块。<h4 id=shell><a class=headerlink href=#shell title=shell></a>shell</h4><p><code>shell</code>模块的官方说明是：<code>Manage files and URLs using their default applications.</code>也就是使用文件或者URL的默认应用。通常我们可以用其让默认图片应用打开一张图片、让默认浏览器打开一个url。<p>如果我们想在renderer进程里点击一个按钮然后在默认浏览器里打开一个url的话就可以这样：<figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag>&lt;<span class=name>button</span> @<span class=attr>click</span>=<span class=string>"openURL"</span>></span><span class=tag>&lt;/<span class=name>button</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&lt;<span class=name>script</span>></span><span class=language-javascript></span></span><br><span class=line><span class=language-javascript>  <span class=keyword>export</span> <span class=keyword>default</span> {</span></span><br><span class=line><span class=language-javascript>    <span class=attr>methods</span>: {</span></span><br><span class=line><span class=language-javascript>      <span class="title function_">openURL</span> () {</span></span><br><span class=line><span class=language-javascript>        <span class="variable language_">this</span>.<span class=property>$electron</span>.<span class=property>remote</span>.<span class=property>shell</span>.<span class="title function_">openExternal</span>(<span class=string>'https://github.com/Molunerfinn/PicGo'</span>)</span></span><br><span class=line><span class=language-javascript>      }</span></span><br><span class=line><span class=language-javascript>    }</span></span><br><span class=line><span class=language-javascript>  }</span></span><br><span class=line><span class=language-javascript></span><span class=tag>&lt;/<span class=name>script</span>></span></span><br></pre></table></figure><p>是不是很方便？<p>更多详细的shell的用法可以参考<a href=https://electronjs.org/docs/api/shell>文档</a>。<h4 id=dialog><a class=headerlink href=#dialog title=dialog></a>dialog</h4><p>有的时候我们会有打开原生的对话框的需求。比如<code>PicGo</code>的版本信息：<blockquote><p>macOS</blockquote><p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnje5uvnlrj20nc08kq3d><blockquote><p>windows</blockquote><p><img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fnje4njzafj20a60543yd><p>这个时候就可以通过<code>dialog</code>这个模块来实现了。逻辑跟上面一样也是点击一个按钮打开一个dialog：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class="title function_">openDialog</span> () {</span><br><span class=line>  <span class="variable language_">this</span>.<span class=property>$electron</span>.<span class=property>remote</span>.<span class=property>dialog</span>.<span class="title function_">showMessageBox</span>({</span><br><span class=line>    <span class=attr>title</span>: <span class=string>'PicGo'</span>,</span><br><span class=line>    <span class=attr>message</span>: <span class=string>'PicGo'</span>,</span><br><span class=line>    <span class=attr>detail</span>: <span class=string>`Version: <span class=subst>${pkg.version}</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class=line>  })</span><br><span class=line>}</span><br></pre></table></figure><p>更多详细的dialog的用法可以参考<a href=https://electronjs.org/docs/api/dialog>文档</a>。<h4 id=Menu和BrowserWindow的应用><a class=headerlink href=#Menu和BrowserWindow的应用 title=Menu和BrowserWindow的应用></a>Menu和BrowserWindow的应用</h4><p>使用<code>Menu</code>可能很多人能够理解。但是为什么要使用<code>BrowserWindow</code>呢？因为需要定位你打开<code>Menu</code>的窗口。<p>在PicGo里，有一个点击按钮打开Menu的操作，大致如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class="title function_">buildMenu</span> () {</span><br><span class=line>    <span class=keyword>const</span> template = [...]</span><br><span class=line>    <span class="variable language_">this</span>.<span class=property>menu</span> = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>(template)</span><br><span class=line>  },</span><br><span class=line>  <span class="title function_">openDialog</span> () {</span><br><span class=line>    <span class="variable language_">this</span>.<span class=property>menu</span>.<span class="title function_">popup</span>(remote.<span class=property>getCurrentWindow</span>) <span class=comment>// 获取当前打开Menu的窗口</span></span><br><span class=line>  }</span><br></pre></table></figure><p>这里的<code>menu.popup</code>就需要你指定一下打开这个menu的窗口。它将自动定位你点击的位置而弹出。<h3 id=main进程和renderer进程的通信><a class=headerlink href=#main进程和renderer进程的通信 title=main进程和renderer进程的通信></a>main进程和renderer进程的通信</h3><p>在Vue里，如果是非父子组件通信，很常用的是通过<code>Bus Event</code>来实现的。而electron里的不同进程间的通信其实也很类似，是通过<code>ipcMain</code>和<code>ipcRenderer</code>来实现的。其中<code>ipcMain</code>是在<code>main</code>进程里使用的，而<code>ipcRenderer</code>是在<code>renderer</code>进程里使用的。<h4 id=ipcMain和ipcRenderer><a class=headerlink href=#ipcMain和ipcRenderer title=ipcMain和ipcRenderer></a>ipcMain和ipcRenderer</h4><p>官网的例子其实很简洁明了了，我放出来：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// In main process.</span></span><br><span class=line><span class=keyword>const</span> {ipcMain} = <span class=built_in>require</span>(<span class=string>'electron'</span>)</span><br><span class=line>ipcMain.<span class="title function_">on</span>(<span class=string>'asynchronous-message'</span>, <span class=function>(<span class=params>event, arg</span>) =></span> {</span><br><span class=line>  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)  <span class=comment>// prints "ping"</span></span><br><span class=line>  event.<span class=property>sender</span>.<span class="title function_">send</span>(<span class=string>'asynchronous-reply'</span>, <span class=string>'pong'</span>)</span><br><span class=line>})</span><br><span class=line></span><br><span class=line>ipcMain.<span class="title function_">on</span>(<span class=string>'synchronous-message'</span>, <span class=function>(<span class=params>event, arg</span>) =></span> {</span><br><span class=line>  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)  <span class=comment>// prints "ping"</span></span><br><span class=line>  event.<span class=property>returnValue</span> = <span class=string>'pong'</span></span><br><span class=line>})</span><br></pre></table></figure><figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// In renderer process (web page).</span></span><br><span class=line><span class=keyword>const</span> {ipcRenderer} = <span class=built_in>require</span>(<span class=string>'electron'</span>)</span><br><span class=line><span class="variable language_">console</span>.<span class="title function_">log</span>(ipcRenderer.<span class="title function_">sendSync</span>(<span class=string>'synchronous-message'</span>, <span class=string>'ping'</span>)) <span class=comment>// prints "pong"</span></span><br><span class=line></span><br><span class=line>ipcRenderer.<span class="title function_">on</span>(<span class=string>'asynchronous-reply'</span>, <span class=function>(<span class=params>event, arg</span>) =></span> {</span><br><span class=line>  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg) <span class=comment>// prints "pong"</span></span><br><span class=line>})</span><br><span class=line>ipcRenderer.<span class="title function_">send</span>(<span class=string>'asynchronous-message'</span>, <span class=string>'ping'</span>)</span><br></pre></table></figure><p>其中<code>ipcMain</code>只有监听来自<code>ipcRenderer</code>的某个事件后才能返回给<code>ipcRenderer</code>值。而<code>ipcRenderer</code>既可以收，也可以发。<p>那么问题就来了，如何让<code>ipcMain</code>主动发送消息呢？或者说让main进程主动发送消息给<code>ipcRenderer</code>。<p>首先要明确的是，<code>ipcMain</code>无法主动发消息给<code>ipcRenderer</code>。因为ipcMain只有<code>.on()</code>方法没有<code>.send()</code>的方法。所以只能用其他方法来实现。有办法么？有的，用<code>webContents</code>。<h4 id=webContents><a class=headerlink href=#webContents title=webContents></a>webContents</h4><p><code>webContents</code>其实是<code>BrowserWindow</code>实例的一个属性。也就是如果我们需要在<code>main</code>进程里给某个窗口某个页面发送消息，则必须通过<code>win.webContents.send()</code>方法来发送。<p>代码大致如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment>// In main process</span></span><br><span class=line><span class=keyword>let</span> win = <span class=keyword>new</span> <span class="title class_">BrowserWindow</span>({...})</span><br><span class=line>win.<span class=property>webContents</span>.<span class="title function_">send</span>(<span class=string>'img-files'</span>, imgs)</span><br></pre></table></figure><figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// In renderer process</span></span><br><span class=line>ipcRenderer.<span class="title function_">on</span>(<span class=string>'img-files'</span>, <span class=function>(<span class=params>event, files</span>) =></span> {</span><br><span class=line>  <span class="variable language_">console</span>.<span class="title function_">log</span>(files)</span><br><span class=line>})</span><br></pre></table></figure><p>所以必须指定要发送的窗口，才能将信息准确送达。<h2 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h2><p>本文详细地讲述了electron里<code>Main</code>进程和<code>Renderer</code>进程的基础知识和开发相关。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。内容相比第一篇多了不少，希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href=https://github.com/Molunerfinn/PicGo>PicGo</a>的项目仓库里找到。希望本文能够给你带来帮助，这是我最开心的地方。如果喜欢，欢迎关注我的博客以及本系列文章的后续进展。<blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></blockquote></div></article><div class=post-copyright><div class=post-copyright__author><span class=post-copyright-meta>Author: </span><span class=post-copyright-info><a href=mailto:undefined>Molunerfinn</a></span></div><div class=post-copyright__type><span class=post-copyright-meta>Link: </span><span class=post-copyright-info><a href=https://molunerfinn.com/electron-vue-2/>https://molunerfinn.com/electron-vue-2/</a></span></div><div class=post-copyright__notice><span class=post-copyright-meta>Copyright Notice: </span><span class=post-copyright-info>All articles in this blog are licensed under <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class=post-meta__tag-list><a class=post-meta__tags href=/tags/%E5%89%8D%E7%AB%AF/>前端</a><a class=post-meta__tags href=/tags/Electron/>Electron</a><a class=post-meta__tags href=/tags/Vue/>Vue</a><a class=post-meta__tags href=/tags/Electron-vue/>Electron-vue</a></div><div class=post-qr-code><div class=post-qr-code-item><img class=post-qr-code__img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/alipay.jpg><div class=post-qr-code__desc>支付宝打赏</div></div><div class=post-qr-code-item><img class=post-qr-code__img src=https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/wechat-pay.jpg><div class=post-qr-code__desc>微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="https://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5994f8f0fea9a5f4" async></script><nav id=pagination><div class="prev-post pull-left"><a href=/electron-vue-3/><i class="fa fa-chevron-left"> </i><span>Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb</span></a></div><div class="next-post pull-right"><a href=/electron-vue-1/><span>Electron-vue开发实战0——Electron-vue入门</span><i class="fa fa-chevron-right"></i></a></div></nav><div class=post-adv><div align=center><sup>Special thanks to:</sup><br><a href=https://go.warp.dev/picgo><img alt="Warp sponsorship" src=https://raw.githubusercontent.com/warpdotdev/brand-assets/refs/heads/main/Github/Sponsor/Warp-Github-LG-03.png width=400></a><div><a href=https://go.warp.dev/picgo>Warp, the intelligent terminal for developers</a></div><a href=https://go.warp.dev/picgo>Available for MacOS, Linux, & Windows</a><br></div></div><div id=gitalk-container></div><script>var gitalk = new Gitalk({
  clientID: 'f7b6cca0b0a65f07a027',
  clientSecret: '7f2daa09738c589122bf2882ee8cdbc62607c4d8',
  repo: 'Molunerfinn.github.io',
  owner: 'Molunerfinn',
  admin: 'Molunerfinn',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer style="background-image: url(https://pics.molunerfinn.com/blog/blog-bg.jpg)" class=footer-bg><div class=layout id=footer><div class=copyright>©2015 - 2025 By Molunerfinn</div><div class=framework-info><span>Driven - </span><a href=http://hexo.io><span>Hexo</span></a><span class=footer-separator>|</span><span>Theme - </span><a href=https://github.com/Molunerfinn/hexo-theme-melody><span>Melody</span></a></div><div class=busuanzi><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_page_pv><i class="fa fa-file-o"></i><span id=busuanzi_value_page_pv></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" aria-hidden=true id=go-up></i><script src=https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/fancybox.js></script><script src=/js/sidebar.js></script><script src=/js/copy.js></script><script src=/js/fireworks.js></script><script src=/js/transition.js></script><script src=/js/scroll.js></script><script src=/js/head.js></script><script src=/js/search/algolia.js></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class=search-dialog id=algolia-search><div class=search-dialog__title id=algolia-search-title>Algolia</div><div id=algolia-input-panel><div id=algolia-search-input></div></div><hr><div id=algolia-search-results><div id=algolia-hits></div><div id=algolia-pagination></div><div id=algolia-stats></div></div><span class=search-close-button><i class="fa fa-times"></i></span></div><div class=search-mask></div>